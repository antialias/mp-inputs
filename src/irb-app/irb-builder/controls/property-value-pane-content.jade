- const selectedProperty = stageClause && stageClause.value;
- const selectedType = stageClause && stageClause.filterType;
- const selectedOperator = stageClause && stageClause.filterOperator;
- const selectedValue = stageClause && stageClause.filterValue;
- const selectedDateUnit = stageClause && stageClause.filterDateUnit;

.pane-content(class=selectedType ? `filter-type-${selectedType}` : '')
  table.tabs
    tbody
      tr
        for typeChoice in $component.filterTypeChoices
          td(class=`type-${typeChoice}` class={selected: typeChoice === selectedType})
            button(
              onclick=() => $helpers.updateStageClause({filterType: typeChoice, filterValue: null, filterSearch: null, editing: null})
            )= util.renamePropertyType(typeChoice)

  if selectedType

    // "operator" input - present on all panes

    case selectedType
      when 'boolean'
      when 'list'
        .filter-operator-input= $component.child('operator-toggle')
      default
        .filter-operator-input= $component.child('operator-dropdown')

    // type-specific inputs

    case selectedType
      when 'string'
        case selectedOperator
          when 'equals'
          when 'does not equal'
            if selectedValue && selectedValue.length
              .filter-string-equals-summary= `${selectedValue.length} selected`

            .filter-string-equals-search.search
              // TODO: we are required to recreate this input between panes switches because of
              //       limitations of the focus-input; this shouldn't be necessary
              if $component.isPaneActive()
                focus-input(
                  autoFocus=$component.isPaneActive()
                  focusDelay=200
                  type='text'
                  value=stageClause.filterSearch
                  oninput=event => $helpers.updateStageClause({filterSearch: event.target.value})
                )

            ul.filter-string-equals-choices
              for value in $helpers.getValueMatches(stageClause.filterSearch)
                li(class={selected: selectedValue && selectedValue.indexOf(value) !== -1})
                  button(onclick=() => $helpers.toggleStringEqualsValueSelected(value))= util.renamePropertyValue(value)

          when 'contains'
          when 'does not contain'
            .filter-value-input
              // TODO: we are required to recreate this input between panes switches because of
              //       limitations of the focus-input; this shouldn't be necessary
              if $component.isPaneActive()
                focus-input(
                  autoFocus=$component.isPaneActive()
                  focusDelay=200
                  type='text'
                  value=selectedValue
                  oninput=ev => $helpers.updateStageClause({filterValue: ev.target.value})
                )

              if selectedValue
                ul.filter-string-contains-matches
                  for value in $helpers.getValueMatches(selectedValue, selectedOperator === 'does not contain')
                    li= util.renamePropertyValue(value)

      when 'number'
        case selectedOperator
          when 'is between'
            - const betweenStart = selectedValue ? selectedValue[0] : null;
            - const betweenEnd = selectedValue ? selectedValue[1] : null;
            .filter-value-input.filter-operator-between
              // TODO: we are required to recreate this input between panes switches because of
              //       limitations of the focus-input; this shouldn't be necessary
              if $component.isPaneActive()
                focus-input(
                  autoFocus=$component.isPaneActive()
                  focusDelay=200
                  type='number'
                  value=betweenStart
                  oninput=ev => $helpers.updateStageClause({filterValue: [Number(ev.target.value), betweenEnd]})
                )
              .connector and
              input(
                type='number'
                value=betweenEnd
                oninput=ev => $helpers.updateStageClause({filterValue: [betweenStart, Number(ev.target.value)]})
              )
          default
            .filter-value-input
              // TODO: we are required to recreate this input between panes switches because of
              //       limitations of the focus-input; this shouldn't be necessary
              if $component.isPaneActive()
                focus-input(
                  autoFocus=$component.isPaneActive()
                  focusDelay=200
                  type='number'
                  value=selectedValue
                  oninput=ev => $helpers.updateStageClause({filterValue: Number(ev.target.value)})
                )

      when 'datetime'
        case selectedOperator
          when 'was between'
          when 'was on'
            - const from = selectedValue ? selectedValue[0] : null;
            - const to = selectedValue ? selectedValue[1] : null;
            .filter-value-input
              date-picker(
                value=JSON.stringify({from, to})
                onchange=ev => $helpers.updateStageClause({filterValue: [new Date(ev.target.value.from), new Date(ev.target.value.to)]})
              )
          default
            .filter-value-input.filter-days-ago
              // TODO: we are required to recreate this input between panes switches because of
              //       limitations of the focus-input; this shouldn't be necessary
              if $component.isPaneActive()
                focus-input(
                  autoFocus=$component.isPaneActive()
                  focusDelay=200
                  type='number'
                  value=selectedValue
                  oninput=ev => $helpers.updateStageClause({filterValue: Number(ev.target.value)})
                )
              .filter-unit-input= $component.child('date-unit-dropdown')
              .connector ago

      when 'list'
        .filter-value-input
          // TODO: we are required to recreate this input between panes switches because of
          //       limitations of the focus-input; this shouldn't be necessary
          if $component.isPaneActive()
            focus-input(
              autoFocus=$component.isPaneActive()
              focusDelay=200
              type='text'
              value=selectedValue
              oninput=ev => $helpers.updateStageClause({filterValue: ev.target.value})
            )
