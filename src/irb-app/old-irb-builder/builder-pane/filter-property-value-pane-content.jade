- const selectedProperty = $helpers.getActiveClauseProperty('value');
- const selectedType = $helpers.getActiveClauseProperty('filterType');
- const selectedOperator = $helpers.getActiveClauseProperty('filterOperator');
- const selectedValue = $helpers.getActiveClauseProperty('filterValue');
- const selectedDateUnit = $helpers.getActiveClauseProperty('filterDateUnit');

.property.pane-content(class={[`filter-type-${selectedType}`]: !!selectedType})
  .filter-tabs
    each typeChoice in $component.filterTypeChoices
      .filter-tab(class={
        selected: typeChoice === selectedType,
        [`type-${typeChoice}`]: true,
      })
        .filter-button-wrapper(on={click: () => $helpers.selectFilterType(typeChoice)})
          svg-icon(attrs={icon: $helpers.typeIcon(typeChoice)})
          button= util.renamePropertyType(typeChoice)

  if selectedType

    // "operator" input - present on all panes

    case selectedType
      when 'boolean'
      when 'list'
        .filter-operator-input= $component.child('operator-toggle')
      default
        .filter-operator-input= $component.child('operator-dropdown')

    // type-specific inputs

    case selectedType
      when 'string'
        case selectedOperator
          when 'equals'
          when 'does not equal'
            if selectedValue && selectedValue.length
              .filter-string-equals-summary= `${selectedValue.length} selected`

            .filter-string-equals-search.search
              // TODO: we are required to recreate this input between panes switches because of
              //       limitations of the focus-input; this shouldn't be necessary
              if $component.isPaneActive()
                focus-input(
                  props={
                    autoFocus: $component.isPaneActive(),
                    focusDelay: 200,
                    type: 'text',
                  }
                  on={input: event => $helpers.updateStageClause({filterSearch: event.target.value})}
                )

            ul.filter-string-equals-choices
              each value in $helpers.getEqualsMatches()
                li(class={selected: selectedValue && selectedValue.indexOf(value) !== -1})
                  button(on={click: () => $helpers.toggleStringEqualsValueSelected(value)})= util.renamePropertyValue(value)

          when 'contains'
          when 'does not contain'
            .filter-value-input
              // TODO: we are required to recreate this input between panes switches because of
              //       limitations of the focus-input; this shouldn't be necessary
              if $component.isPaneActive()
                focus-input(
                  props={
                    autoFocus: $component.isPaneActive(),
                    focusDelay: 200,
                    type: 'text',
                    value: selectedValue,
                  }
                  on={input: ev => $helpers.updateStageClause({filterValue: event.target.value})}
                )

              if selectedValue
                ul.filter-string-contains-matches
                  each value in $helpers.getValueMatches(selectedValue, selectedOperator === 'does not contain')
                    li= util.renamePropertyValue(value)

      when 'number'
        case selectedOperator
          when 'is between'
            - const betweenStart = selectedValue ? selectedValue[0] : null;
            - const betweenEnd = selectedValue ? selectedValue[1] : null;
            .filter-value-input.filter-operator-between
              // TODO: we are required to recreate this input between panes switches because of
              //       limitations of the focus-input; this shouldn't be necessary
              if $component.isPaneActive()
                focus-input(
                  props={
                    autoFocus: $component.isPaneActive(),
                    focusDelay: 200,
                    type: 'number',
                    value: betweenStart,
                  }
                  on={input: ev => $helpers.updateStageClause({filterValue: [Number(ev.target.value), betweenEnd]})}
                )

              .connector and
              input(
                props={
                  type: 'number',
                  value: betweenEnd,
                }
                on={input: ev => $helpers.updateStageClause({filterValue: [betweenStart, Number(ev.target.value)]})}
              )
          default
            .filter-value-input
              // TODO: we are required to recreate this input between panes switches because of
              //       limitations of the focus-input; this shouldn't be necessary
              if $component.isPaneActive()
                focus-input(
                  props={
                    autoFocus: $component.isPaneActive(),
                    focusDelay: 200,
                    type: 'number',
                    value: selectedValue,
                  }
                  on={input: ev => $helpers.updateStageClause({filterValue: Number(ev.target.value)})}
                )

      when 'datetime'
        case selectedOperator
          when 'was between'
            - const from = selectedValue ? selectedValue[0] : null;
            - const to = selectedValue ? selectedValue[1] : null;
            .filter-value-input.filter-date
              mp-calendar(
                attrs={range: true}
                props={value: JSON.stringify({from, to})}
                on={change: $helpers.updateDate}
              )
          when 'was on'
            .filter-value-input.filter-date
              mp-calendar(on={change: $helpers.updateDate})
          default
            .filter-value-input.filter-days-ago
              // TODO: we are required to recreate this input between panes switches because of
              //       limitations of the focus-input; this shouldn't be necessary
              if $component.isPaneActive()
                focus-input(
                  props={
                    autoFocus: $component.isPaneActive(),
                    focusDelay: 200,
                    type: 'number',
                    value: selectedValue,
                  }
                  on={input: ev => $helpers.updateStageClause({filterValue: Number(ev.target.value)})}
                )
              .filter-unit-input= $component.child('date-unit-dropdown')
              .connector ago

      when 'list'
        .filter-value-input
          // TODO: we are required to recreate this input between panes switches because of
          //       limitations of the focus-input; this shouldn't be necessary
          if $component.isPaneActive()
            focus-input(
              props={
                autoFocus: $component.isPaneActive(),
                focusDelay: 200,
                type: 'text',
                value: selectedValue,
              }
              on={input: ev => $helpers.updateStageClause({filterValue: ev.target.value})}
            )
