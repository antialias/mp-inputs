- const selectedProperty = state.editingClause && state.editingClause.value;

- const typeChoices = constants.filterTypeChoices;
- const selectedType = state.editingClause && state.editingClause.filterType;

- const operatorChoices = constants.filterOperatorChoices[selectedType];
- const selectedOperator = state.editingClause && state.editingClause.filterOperator;

- const valueChoices = state.editingClause && state.topPropertyValues;
- const selectedValue = state.editingClause && state.editingClause.filterValue;

div(class=[elementClass, selectedType ? `filter-type-${selectedType}` : ''])
  table.tabs
    tbody
      tr
        for filterType in typeChoices
          td(class=['type-' + filterType, filterType === selectedType ? 'selected' : ''])
            button(
              ev-click=() => helpers.updateClause(state.clauseIndex, {filterType, filterValue: null, filterSearch: null, editing: null})
            )= util.renamePropertyType(filterType)

  if selectedType

    // "operator" input - present on all panes

    if selectedType === 'boolean' || selectedType === 'list'
      .filter-operator-input= views.operatorToggle({choices: operatorChoices, selected: selectedOperator})
    else
      .filter-operator-input= views.operatorDropdown({open: state.editingClause.editingFilterOperator, choices: operatorChoices, selected: selectedOperator})

    // type-specific inputs

    if selectedType === 'string'
      if selectedOperator === 'equals' || selectedOperator === 'does not equal'
        if selectedValue && selectedValue.length
          .filter-string-equals-summary= `${selectedValue.length} selected`

        .filter-string-equals-search.search
          input(
            type='text'
            value=state.editingClause.filterSearch
            ev-input=event => helpers.updateClause(state.clauseIndex, {filterSearch: event.target.value})
          )

        ul.filter-string-equals-choices
          for value in helpers.getValueMatches(state.editingClause.filterSearch)
            li(class=selectedValue && selectedValue.indexOf(value) !== -1 ? 'selected' : '')
              button(ev-click=() => helpers.toggleStringEqualsValueSelected(value))= value

      else if selectedOperator === 'contains' || selectedOperator === 'does not contain'
        .filter-value-input
          input(
            type='text'
            value=selectedValue
            ev-input=event => helpers.updateClause(state.clauseIndex, {filterValue: event.target.value})
          )

          if selectedValue
            ul.filter-string-contains-matches
              for value in helpers.getValueMatches(selectedValue, selectedOperator === 'does not contain')
                li= value

    else if selectedType === 'number'
      if selectedOperator === 'is between'
        - const betweenStart = selectedValue ? selectedValue[0] : null;
        - const betweenEnd = selectedValue ? selectedValue[1] : null;
        .filter-value-input.filter-operator-between
          input(
            type='number'
            value=betweenStart
            ev-input=event => helpers.updateClause(state.clauseIndex, {filterValue: [Number(event.target.value), betweenEnd]})
          )
          .connector and
          input(
            type='number'
            value=betweenEnd
            ev-input=event => helpers.updateClause(state.clauseIndex, {filterValue: [betweenStart, Number(event.target.value)]})
          )
      else
        .filter-value-input
          input(
            type='number'
            value=selectedValue
            ev-input=event => helpers.updateClause(state.clauseIndex, {filterValue: Number(event.target.value)})
          )
  //
    ul.column.resource-value
      if helpers.showPropertyValues()
        for filterValue, i in state.topPropertyValues
          if helpers.matchesSearch(filterValue)
            li(
              class=filterValue === selectedValue ? 'selected' : '',
              ev-click=() => helpers.updateClause(state.clauseIndex, {filterValue}),
            )= filterValue
