mixin pane(paneViews, isPaneActive, paneIndex)
  - const paneConstants = util.extend(constants, (constants.panes && constants.panes[paneIndex]) || {});
  - const paneHelpers = util.extend(helpers, (helpers.panes && helpers.panes[paneIndex]) || {});
  - const paneHandlers = util.extend(handlers, (handlers.panes && handlers.panes[paneIndex]) || {});

  - const header = paneConstants.header || paneHelpers.getHeader && paneHelpers.getHeader();
  - const commitLabel = paneConstants.commitLabel || paneHelpers.getCommitLabel && paneHelpers.getCommitLabel();
  - const commitHandler = paneHandlers.commitHandler;

  if header
    .header
      span= header
      if paneIndex
        button.back(ev-click=() => helpers.updateStageClause({paneIndex: paneIndex - 1}))

  if paneConstants.search !== false && constants.search !== false
    .search
      // TODO: we are required to recreate this input between panes switches because of 
      //       limitations of the focus-input; this shouldn't be necessary
      if isPaneActive
        focus-input(autoFocus=isPaneActive type='text' ev-input=event => helpers.updateStageClause({search: event.target.value}))

  if paneViews.content
    .content= paneViews.content(util.extend(state, {isPaneActive}))

  if commitLabel && commitHandler
    button.commit(ev-click=commitHandler)= commitLabel

.pane-view(class=elementClass)
  if views.panes
    - const activePaneIndex = (state.stageClause && state.stageClause.paneIndex) || 0;

    for paneViews, paneIndex in views.panes
      .pane(style={
        '-webkit-transform': `translateX(${(paneIndex - activePaneIndex) * 400}px)`,
        transform: `translateX(${(paneIndex - activePaneIndex) * 400}px)`,
      })
        +pane(paneViews, paneIndex === activePaneIndex, paneIndex)
  else
    .pane.active
        +pane(views, true)
