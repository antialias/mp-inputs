include ../../mixins.jade
include ../mixins.jade

mixin filter-dropdown(name, title, icon)
  div(class={[`filter-${name}-dropdown`]: true})
    button.filter-menu-button(on={click: () => $helpers.toggleMenu(name)})
      span.button-flex-wrapper
        svg-icon(attrs={icon, empty: !icon})
        span.filter-prop-name= title
        svg-icon(attrs={icon: `caret-down`})
    .filter-menu
      mp-drop-menu(
        attrs={open: $helpers.isMenuOpen(name)}
        on={change: ev => $helpers.menuChange(ev, name)}
      )
        block

mixin filter-operator-dropdown
  +filter-dropdown(`operator`, clause.filterOperator)
    ul.filter-operators
      each filterOperator in $helpers.FILTER_OPERATORS[clause.filterType]
        li.filter-menu-item(
          class={'filter-menu-item-selected': filterOperator === clause.filterOperator}
          on={click: () => $helpers.chooseFilterOperator(filterOperator)}
        )= filterOperator

mixin filter-string-input
  .filter-string-input-wrapper
    //- TODO: handle focus properly. Sadly setTimeout is an easy working solution.
    //- There is a racecondition with visible inputs in the filter screen that we need to solve for.
    input.filter-string-input(
      props={
        type: `text`,
        value: clause.filterValue,
        placeholder: ``,
      }
      on={
        input: ev => $helpers.updateFilterValue(ev.target.value),
      }
      hook={
        insert: vnode => setTimeout(() => vnode.elm.focus(), 250),
      }
    )

mixin filter-number-input(value, oninput, options)
  .filter-number-input-wrapper
    //- TODO: handle focus properly. See filter-string-input above.
    input.filter-numdate-input(
      props={
        type: `text`,
        value,
      }
      on={
        input: oninput,
      }
      hook=options.autofocus ? {insert: vnode => setTimeout(() => vnode.elm.focus(), 250)} : {}
      key=options.key
    )

- const clause = $helpers.getActiveClause()
.builder-screen.filter-property
  +screen-title(``, {backButton: true})
    +filter-dropdown(`type`, util.renameProperty(clause.value), util.getIconForPropertyType(clause.filterType))
      ul.filter-types
        each filterType in $helpers.FILTER_TYPES
          li.filter-menu-item(
            class={'filter-menu-item-selected': filterType.name === clause.filterType}
            on={click: () => $helpers.chooseFilterType(filterType.name)}
          )
            svg-icon(attrs={icon: filterType.icon})
            = filterType.name

  .filter-chooser(
    class={[`filter-type-${clause.filterType}`]: true}
    hook={postpatch: $helpers.updateRenderedSize}
  )
    case clause.filterType

      when `string`
        - const isLoading = $helpers.isLoading()
        +filter-operator-dropdown
        case clause.filterOperator
          when `equals`
          when `does not equal`
            .filter-string-input-wrapper.filter-string-search
              svg-icon(attrs={icon: `search`})
              input.filter-string-input(
                props={
                  type: `text`,
                  placeholder: `Search`,
                  value: clause.filterSearch,
                }
                on={
                  input: ev => $helpers.updateFilterSearch(ev.target.value),
                }
              )

            .screen-list-container(on={scroll: $helpers.scrolledList})
              if isLoading
                +pane-loader
              else
                ul.filter-string-equals-choices
                  +checkbox-select-all(
                    $helpers.allEqualsValuesSelected(),
                    $helpers.toggleAllFilterValues
                  )
                  each value in $helpers.getEqualsMatches()
                    +checkbox-item(
                      util.renamePropertyValue(value),
                      value,
                      clause.filterValue && clause.filterValue.indexOf(value) !== -1,
                      $helpers.toggleStringEqualsValueSelected
                    )

          when `contains`
          when `does not contain`
            +filter-string-input
            if isLoading
              +pane-loader
            else
              .screen-list-container(on={scroll: $helpers.scrolledList})
                ul.filter-string-contains-choices
                  each value in $helpers.getContainsMatches()
                    - const formattedValue = util.renamePropertyValue(value)
                    li.string-contains-match(on={click: () => $helpers.clickedContainsMatch(formattedValue)})
                      = formattedValue

      when `number`
        +filter-operator-dropdown
        if clause.filterOperator === `is between`
          - const [start, end] = clause.filterValue || [null, null]
          .filter-numdate.filter-numdate-between
            +filter-number-input(
              start,
              ev => $helpers.updateFilterValue([Number(ev.target.value), end]),
              {autofocus: true, key: `num-start`}
            )
            span.filter-conjunction and
            +filter-number-input(
              end,
              ev => $helpers.updateFilterValue([start, Number(ev.target.value)]),
              {autofocus: false, key: `num-end`}
            )
        else
          .filter-numdate
            +filter-number-input(
              clause.filterValue,
              ev => $helpers.updateFilterValue(Number(ev.target.value)),
              {autofocus: true, key: `num-val: ${clause.filterOperator}`}
            )

      when `datetime`
        +filter-operator-dropdown
        case clause.filterOperator
          when `was on`
          when `was between`
            - const [from, to] = Array.isArray(clause.filterValue) ? clause.filterValue : [null, null];
            - const isBetween = clause.filterOperator === `was between`
            .filter-numdate
              insights-datepicker(
                attrs={
                  'max-data-history': $helpers.getMaxDataHistoryDays(),
                  range: isBetween,
                  preposition: `and`,
                }
                props={
                  value: isBetween ? {from, to} : clause.filterValue,
                  utcOffset: $helpers.getUtcOffset(),
                }
                on={change: ev => $helpers.updateFilterValue(isBetween ? [ev.detail.from, ev.detail.to] : ev.detail)}
              )
          when `was in the`
            ul.screen-options-list
              each range in $helpers.TIME_RANGE_NAMES
                - const {value, unit} = $helpers.TIME_RANGE_VALUES[range]
                li.list-option(
                  class={'list-option-selected': value === clause.filterValue && unit === clause.filterDateUnit}
                  on={click: () => $helpers.updateFilterValue(value, unit)}
                )
                  .option-label= range

      when `boolean`
        .filter-radio-list.filter-boolean
          .radio-button(
            class={'radio-selected': clause.filterOperator === `is true`}
            on={click: () => $helpers.chooseFilterOperator(`is true`)}
          ) True
          .radio-button(
            class={'radio-selected': clause.filterOperator === `is false`}
            on={click: () => $helpers.chooseFilterOperator(`is false`)}
          ) False

      when `list`
        .filter-radio-list.filter-list
          .radio-button(
            class={'radio-selected': clause.filterOperator === `contains`}
            on={click: () => $helpers.chooseFilterOperator(`contains`)}
          ) Contains
          .radio-button(
            class={'radio-selected': clause.filterOperator === `does not contain`}
            on={click: () => $helpers.chooseFilterOperator(`does not contain`)}
          ) Does not contain
        +filter-string-input

  +screen-footer-button(`Add filter`, {onclick: $helpers.commitFilter})
